#!/usr/bin/python

# An openstack ansible install runner

import curses
import datetime
import fcntl
import json
import os
import psutil
import re
import select
import subprocess
import sys
import textwrap
import time

import emitters
import steps


progname = os.path.basename(__file__)


class Runner(object):
    def __init__(self, screen):
        self.screen = screen

        self.steps = {}

        self.state_path = os.path.expanduser('~/.%s/state.json' % progname)
        if not os.path.exists(os.path.expanduser('~/.%s' % progname)):
            os.mkdir(os.path.expanduser('~/.%s' % progname))

        self.complete = {}
        self.counter = 0
        if os.path.exists(self.state_path):
            with open(self.state_path, 'r') as f:
                state = json.loads(f.read())
                self.complete = state.get('complete', {})
                self.counter = state.get('counter', 0)

    def load_step(self, step):
        self.steps[step.name] = step

    def load_dependancy_chain(self, steps, depends=None):
        depend = depends
        for step in steps:
            step.depends = depend
            depend = step.name
            self.load_step(step)

    def resolve_steps(self):
        # Setup curses windows for the steps view
        height, width = self.screen.getmaxyx()
        progress = curses.newwin(3, width, 0, 0)
        progress.border()
        progress.refresh()

        output = curses.newwin(height - 4, width, 3, 0)
        output.scrollok(True)
        output.border()
        output.refresh()
        emitter = emitters.Emitter(progname, output)

        for step_name in self.complete:
            if step_name in self.steps:
                del self.steps[step_name]

        run = [True]
        complete = []

        while len(run) > 0:
            run = []
            complete = []

            for step_name in self.steps:
                step = self.steps[step_name]

                if not step.depends or self.complete.get(step.depends, False):
                    progress.clear()
                    progress.addstr(1, 3, '%s %d steps to run, running %s'
                                    % (datetime.datetime.now(),
                                       len(self.steps),
                                       step_name))
                    progress.border()
                    progress.refresh()

                    run.append(step_name)
                    emitter.clear()
                    emitter.logger('%06d-%s' % (self.counter, step_name))
                    outcome = step.run(emitter, self.screen)
                    self.counter += 1

                    if outcome:
                        self.complete[step_name] = outcome
                        complete.append(step_name)

                    with open(self.state_path, 'w') as f:
                        f.write(json.dumps({'complete': self.complete,
                                            'counter': self.counter},
                                           indent=4, sort_keys=True))

            for step_name in complete:
                del self.steps[step_name]


def main(screen):
    screen.nodelay(False)
    r = Runner(screen)

    # We really like screen around here
    r.load_step(steps.SimpleCommandStep(
            'apt-daily',
            ('while [ `ps -ef | grep apt.systemd.daily | '
             'grep -vc "grep"` -gt 0 ]; do '
             'echo "Waiting for daily apt run to end"; sleep 10; done')
            ))
    r.resolve_steps()

    # git proxies
    r.load_dependancy_chain(
        [steps.QuestionStep(
                    'git-mirror-github',
                    'Are you running a local github.com mirror?',
                    ('Mirroring github.com speeds up setup on slow and '
                     'unreliable networks, but means that you have to '
                     'maintain a mirror somewhere on your corporate network. '
                     'If you are unsure, just enter "git://github.com" here. '
                     'Otherwise, we need an answer in the form of '
                     '<protocol>://<server>, for example '
                     'git://gitmirror.example.com'),
                    'Mirror URL'),
         steps.QuestionStep(
                     'git-mirror-openstack',
                     'Are you running a local git.openstack.org mirror?',
                     ('Mirroring git.openstack.org speeds up setup on slow '
                      'and unreliable networks, but means that you have to '
                      'maintain a mirror somewhere on your corporate network. '
                      'If you are unsure, just enter '
                      '"git://git.openstack.org" here. Otherwise, we need an '
                      'answer in the form of <protocol>://<server>, for '
                      'example git://gitmirror.example.com'),
                     'Mirror URL'),
         steps.QuestionStep(
                     'osa-branch',
                     'What OSA branch (or commit SHA) would you like to use?',
                     'Use stable/newton unless you know what you are doing.',
                     'OSA branch'),
         steps.QuestionStep(
                     'http-proxy',
                     'Are you running a local http proxy?',
                     ('OSA will download large objects such as LXC base '
                      'images. If you have a slow network, or are on a '
                      'corporate network which requires a proxy, configure it '
                      'here with a URL like http://cache.example.com:3128 . '
                      'If you do not use a proxy, please enter "none" here.'),
                     'HTTP Proxy'),
         ])

    # APT commands
    r.load_dependancy_chain(
        [steps.SimpleCommandStep('apt-update', 'apt-get update'),
         steps.SimpleCommandStep('apt-upgrade', 'apt-get upgrade -y'),
         steps.SimpleCommandStep(
                'apt-dist-upgrade',
                'apt-get dist-upgrade -y'),
         steps.SimpleCommandStep(
                'apt-useful',
                'apt-get install -y screen ack-grep git expect')
         ])

    # Do the thing
    r.resolve_steps()

    # Steps requiring data from earlier
    r.load_dependancy_chain(
        [steps.SimpleCommandStep(
                    'git-clone-osa',
                    ('git clone %s/openstack/openstack-ansible '
                     '/opt/openstack-ansible'
                     % r.complete['git-mirror-openstack'])),
         ])

    # Steps where we now have the OSA checkout
    kwargs = {'cwd': '/opt/openstack-ansible',
              'env': {'ANSIBLE_ROLE_FETCH_MODE': 'git-clone'}}
    if r.complete['http-proxy'] and r.complete['http-proxy'] != 'none':
        kwargs['env'].update({'http_proxy': r.complete['http-proxy'],
                              'https_proxy': r.complete['http-proxy']})
    r.load_dependancy_chain(
         [steps.SimpleCommandStep(
                    'git-checkout-osa',
                    'git checkout %s' % r.complete['osa-branch'],
                    **kwargs),
          steps.SimpleCommandStep(
                    'fixup-add-ironic',
                    ('sed -i -e "/- name: heat.yml.aio/ a \        '
                     '- name: ironic.yml.aio"  tests/bootstrap-aio.yml'),
                    **kwargs),
          steps.SimpleCommandStep(
                    'fixup-virt-ironic',
                    ('echo "nova_virt_type: ironic" >> '
                     'etc/openstack_deploy/user_variables.yml'),
                    **kwargs),
          steps.RegexpEditorStep(
                    'ansible-role-assignments-github-mirror',
                    'ansible-role-requirements.yml',
                    '(http|https|git)://github.com',
                    r.complete['git-mirror-github'],
                    **kwargs),
          steps.RegexpEditorStep(
                    'ansible-role-assignments-openstack-mirror',
                    'ansible-role-requirements.yml',
                    '(http|https|git)://git.openstack.org',
                    r.complete['git-mirror-openstack'],
                    **kwargs),
          steps.RegexpEditorStep(
                    'ansible-no-loopback-swap',
                    ('/opt/openstack-ansible/tests/roles/bootstrap-host/'
                     'tasks/prepare_loopback_swap.yml'),
                    'command: grep /openstack/swap.img /proc/swaps',
                    'command: /bin/true',
                    **kwargs),
          steps.RegexpEditorStep(
                    'ansible-from-mirror',
                    '/opt/openstack-ansible/scripts/bootstrap-ansible.sh',
                    'https://github.com/ansible/ansible',
                    '%s/ansible/ansible' % r.complete['git-mirror-github'],
                    **kwargs),
          steps.SimpleCommandStep(
                    'bootstrap-ansible',
                    './scripts/bootstrap-ansible.sh',
                    **kwargs),
          steps.SimpleCommandStep(
                    'lxc-install',
                    'apt-get install -y lxc',
                    **kwargs),
          steps.RegexpEditorStep(
                    'lxc-cachable-downloads',
                    '/usr/share/lxc/templates/lxc-download',
                    'wget_wrapper -T 30 -q https?://',
                    'wget_wrapper -T 30 -q --no-hsts http://',
                    **kwargs),
          steps.SimpleCommandStep(
                    'bootstrap-aio',
                    './scripts/bootstrap-aio.sh',
                    **kwargs),
          steps.RegexpEditorStep(
                    'repo-container-retries',
                    '/etc/ansible/roles/repo_build/tasks/repo_clone_git.yml',
                    'retries: 360',
                    'retries: 3600',
                    **kwargs),
          ],
         depends='git-clone-osa')

    r.resolve_steps()

    # We also need to re-write git repos in a large number of roles
    r.load_step(steps.BulkRegexpEditorStep(
            'apply-git-mirrors-and-http-retries', '/etc/ansible', '.*\.(ini|yml)$',
            [('(http|https|git)://github.com',
              r.complete['git-mirror-github']),
             ('(http|https|git)://git.openstack.org',
              r.complete['git-mirror-openstack']),
             ('  get_url:',
              ('  until: get_url_result | succeeded\n'
               '  retries: 5\n  delay: 30\n  get_url:'))],
            **kwargs))
    r.resolve_steps()

    # The last of the things, run only once
    kwargs['max_attempts'] = 1
    r.load_step(steps.SimpleCommandStep(
                     'run-playbooks',
                     './scripts/run-playbooks.sh',
                     **kwargs))
    r.resolve_steps()


if __name__ == '__main__':
    if ('TMUX' not in os.environ) and ('STY' not in os.environ):
        sys.exit('Only run ostrich in a screen or tmux session please')

    curses.wrapper(main)
